{"version":3,"file":"platform-server.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/platform-server/src/utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  APP_ID,\n  ApplicationRef,\n  CSP_NONCE,\n  InjectionToken,\n  PlatformRef,\n  Provider,\n  Renderer2,\n  StaticProvider,\n  Type,\n  ɵannotateForHydration as annotateForHydration,\n  ɵIS_HYDRATION_DOM_REUSE_ENABLED as IS_HYDRATION_DOM_REUSE_ENABLED,\n  ɵSSR_CONTENT_INTEGRITY_MARKER as SSR_CONTENT_INTEGRITY_MARKER,\n  ɵstartMeasuring as startMeasuring,\n  ɵstopMeasuring as stopMeasuring,\n} from '@angular/core';\nimport {BootstrapContext} from '@angular/platform-browser';\n\nimport {platformServer} from './server';\nimport {PlatformState} from './platform_state';\nimport {BEFORE_APP_SERIALIZED, INITIAL_CONFIG} from './tokens';\nimport {createScript} from './transfer_state';\n\n/**\n * Event dispatch (JSAction) script is inlined into the HTML by the build\n * process to avoid extra blocking request on a page. The script looks like this:\n * ```html\n * <script type=\"text/javascript\" id=\"ng-event-dispatch-contract\">...</script>\n * ```\n * This const represents the \"id\" attribute value.\n */\nexport const EVENT_DISPATCH_SCRIPT_ID = 'ng-event-dispatch-contract';\n\ninterface PlatformOptions {\n  document?: string | Document;\n  url?: string;\n  platformProviders?: Provider[];\n}\n\n/**\n * Creates an instance of a server platform (with or without JIT compiler support\n * depending on the `ngJitMode` global const value), using provided options.\n */\nfunction createServerPlatform(options: PlatformOptions): PlatformRef {\n  const extraProviders = options.platformProviders ?? [];\n  const measuringLabel = 'createServerPlatform';\n  startMeasuring(measuringLabel);\n\n  const platform = platformServer([\n    {provide: INITIAL_CONFIG, useValue: {document: options.document, url: options.url}},\n    extraProviders,\n  ]);\n\n  stopMeasuring(measuringLabel);\n  return platform;\n}\n\n/**\n * Finds and returns inlined event dispatch script if it exists.\n * See the `EVENT_DISPATCH_SCRIPT_ID` const docs for additional info.\n */\nfunction findEventDispatchScript(doc: Document) {\n  return doc.getElementById(EVENT_DISPATCH_SCRIPT_ID);\n}\n\n/**\n * Removes inlined event dispatch script if it exists.\n * See the `EVENT_DISPATCH_SCRIPT_ID` const docs for additional info.\n */\nfunction removeEventDispatchScript(doc: Document) {\n  findEventDispatchScript(doc)?.remove();\n}\n\n/**\n * Annotate nodes for hydration and remove event dispatch script when not needed.\n */\nfunction prepareForHydration(platformState: PlatformState, applicationRef: ApplicationRef): void {\n  const measuringLabel = 'prepareForHydration';\n  startMeasuring(measuringLabel);\n  const environmentInjector = applicationRef.injector;\n  const doc = platformState.getDocument();\n\n  if (!environmentInjector.get(IS_HYDRATION_DOM_REUSE_ENABLED, false)) {\n    // Hydration is diabled, remove inlined event dispatch script.\n    // (which was injected by the build process) from the HTML.\n    removeEventDispatchScript(doc);\n\n    return;\n  }\n\n  appendSsrContentIntegrityMarker(doc);\n\n  const eventTypesToReplay = annotateForHydration(applicationRef, doc);\n  if (eventTypesToReplay.regular.size || eventTypesToReplay.capture.size) {\n    insertEventRecordScript(\n      environmentInjector.get(APP_ID),\n      doc,\n      eventTypesToReplay,\n      environmentInjector.get(CSP_NONCE, null),\n    );\n  } else {\n    // No events to replay, we should remove inlined event dispatch script\n    // (which was injected by the build process) from the HTML.\n    removeEventDispatchScript(doc);\n  }\n  stopMeasuring(measuringLabel);\n}\n\n/**\n * Creates a marker comment node and append it into the `<body>`.\n * Some CDNs have mechanisms to remove all comment node from HTML.\n * This behaviour breaks hydration, so we'll detect on the client side if this\n * marker comment is still available or else throw an error\n */\nfunction appendSsrContentIntegrityMarker(doc: Document) {\n  // Adding a ng hydration marker comment\n  const comment = doc.createComment(SSR_CONTENT_INTEGRITY_MARKER);\n  doc.body.firstChild\n    ? doc.body.insertBefore(comment, doc.body.firstChild)\n    : doc.body.append(comment);\n}\n\n/**\n * Adds the `ng-server-context` attribute to host elements of all bootstrapped components\n * within a given application.\n */\nfunction appendServerContextInfo(applicationRef: ApplicationRef) {\n  const injector = applicationRef.injector;\n  let serverContext = sanitizeServerContext(injector.get(SERVER_CONTEXT, DEFAULT_SERVER_CONTEXT));\n  applicationRef.components.forEach((componentRef) => {\n    const renderer = componentRef.injector.get(Renderer2);\n    const element = componentRef.location.nativeElement;\n    if (element) {\n      renderer.setAttribute(element, 'ng-server-context', serverContext);\n    }\n  });\n}\n\nfunction insertEventRecordScript(\n  appId: string,\n  doc: Document,\n  eventTypesToReplay: {regular: Set<string>; capture: Set<string>},\n  nonce: string | null,\n): void {\n  const measuringLabel = 'insertEventRecordScript';\n  startMeasuring(measuringLabel);\n  const {regular, capture} = eventTypesToReplay;\n  const eventDispatchScript = findEventDispatchScript(doc);\n\n  // Note: this is only true when build with the CLI tooling, which inserts the script in the HTML\n  if (eventDispatchScript) {\n    // This is defined in packages/core/primitives/event-dispatch/contract_binary.ts\n    const replayScriptContents =\n      `window.__jsaction_bootstrap(` +\n      `document.body,` +\n      `\"${appId}\",` +\n      `${JSON.stringify(Array.from(regular))},` +\n      `${JSON.stringify(Array.from(capture))}` +\n      `);`;\n\n    const replayScript = createScript(doc, replayScriptContents, nonce);\n\n    // Insert replay script right after inlined event dispatch script, since it\n    // relies on `__jsaction_bootstrap` to be defined in the global scope.\n    eventDispatchScript.after(replayScript);\n  }\n  stopMeasuring(measuringLabel);\n}\n\n/**\n * Renders an Angular application to a string.\n *\n * @private\n *\n * @param platformRef - Reference to the Angular platform.\n * @param applicationRef - Reference to the Angular application.\n * @returns A promise that resolves to the rendered string.\n */\nexport async function renderInternal(\n  platformRef: PlatformRef,\n  applicationRef: ApplicationRef,\n): Promise<string> {\n  const platformState = platformRef.injector.get(PlatformState);\n  prepareForHydration(platformState, applicationRef);\n  appendServerContextInfo(applicationRef);\n\n  // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.\n  const environmentInjector = applicationRef.injector;\n  const callbacks = environmentInjector.get(BEFORE_APP_SERIALIZED, null);\n  if (callbacks) {\n    const asyncCallbacks: Promise<void>[] = [];\n    for (const callback of callbacks) {\n      try {\n        const callbackResult = callback();\n        if (callbackResult) {\n          asyncCallbacks.push(callbackResult);\n        }\n      } catch (e) {\n        // Ignore exceptions.\n        console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);\n      }\n    }\n\n    if (asyncCallbacks.length) {\n      for (const result of await Promise.allSettled(asyncCallbacks)) {\n        if (result.status === 'rejected') {\n          console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', result.reason);\n        }\n      }\n    }\n  }\n\n  return platformState.renderToString();\n}\n\n/**\n * Destroy the application in a macrotask, this allows pending promises to be settled and errors\n * to be surfaced to the users.\n */\nfunction asyncDestroyPlatform(platformRef: PlatformRef): Promise<void> {\n  return new Promise<void>((resolve) => {\n    setTimeout(() => {\n      platformRef.destroy();\n      resolve();\n    }, 0);\n  });\n}\n\n/**\n * Specifies the value that should be used if no server context value has been provided.\n */\nconst DEFAULT_SERVER_CONTEXT = 'other';\n\n/**\n * An internal token that allows providing extra information about the server context\n * (e.g. whether SSR or SSG was used). The value is a string and characters other\n * than [a-zA-Z0-9\\-] are removed. See the default value in `DEFAULT_SERVER_CONTEXT` const.\n */\nexport const SERVER_CONTEXT = new InjectionToken<string>('SERVER_CONTEXT');\n\n/**\n * Sanitizes provided server context:\n * - removes all characters other than a-z, A-Z, 0-9 and `-`\n * - returns `other` if nothing is provided or the string is empty after sanitization\n */\nfunction sanitizeServerContext(serverContext: string): string {\n  const context = serverContext.replace(/[^a-zA-Z0-9\\-]/g, '');\n  return context.length > 0 ? context : DEFAULT_SERVER_CONTEXT;\n}\n\n/**\n * Bootstraps an application using provided NgModule and serializes the page content to string.\n *\n * @param moduleType A reference to an NgModule that should be used for bootstrap.\n * @param options Additional configuration for the render operation:\n *  - `document` - the document of the page to render, either as an HTML string or\n *                 as a reference to the `document` instance.\n *  - `url` - the URL for the current render request.\n *  - `extraProviders` - set of platform level providers for the current render request.\n *\n * @publicApi\n */\nexport async function renderModule<T>(\n  moduleType: Type<T>,\n  options: {document?: string | Document; url?: string; extraProviders?: StaticProvider[]},\n): Promise<string> {\n  const {document, url, extraProviders: platformProviders} = options;\n  const platformRef = createServerPlatform({document, url, platformProviders});\n  try {\n    const moduleRef = await platformRef.bootstrapModule(moduleType);\n    const applicationRef = moduleRef.injector.get(ApplicationRef);\n\n    const measuringLabel = 'whenStable';\n    startMeasuring(measuringLabel);\n    // Block until application is stable.\n    await applicationRef.whenStable();\n    stopMeasuring(measuringLabel);\n\n    return await renderInternal(platformRef, applicationRef);\n  } finally {\n    await asyncDestroyPlatform(platformRef);\n  }\n}\n\n/**\n * Bootstraps an instance of an Angular application and renders it to a string.\n *\n * @usageNotes\n *\n * ```ts\n * import { BootstrapContext, bootstrapApplication } from '@angular/platform-browser';\n * import { renderApplication } from '@angular/platform-server';\n * import { ApplicationConfig } from '@angular/core';\n * import { AppComponent } from './app.component';\n *\n * const appConfig: ApplicationConfig = { providers: [...] };\n * const bootstrap = (context: BootstrapContext) =>\n *   bootstrapApplication(AppComponent, config, context);\n * const output = await renderApplication(bootstrap);\n * ```\n *\n * @param bootstrap A method that when invoked returns a promise that returns an `ApplicationRef`\n *     instance once resolved. The method is invoked with an `Injector` instance that\n *     provides access to the platform-level dependency injection context.\n * @param options Additional configuration for the render operation:\n *  - `document` - the document of the page to render, either as an HTML string or\n *                 as a reference to the `document` instance.\n *  - `url` - the URL for the current render request.\n *  - `platformProviders` - the platform level providers for the current render request.\n *\n * @returns A Promise, that returns serialized (to a string) rendered page, once resolved.\n *\n * @publicApi\n */\nexport async function renderApplication(\n  bootstrap: (context: BootstrapContext) => Promise<ApplicationRef>,\n  options: {document?: string | Document; url?: string; platformProviders?: Provider[]},\n): Promise<string> {\n  const renderAppLabel = 'renderApplication';\n  const bootstrapLabel = 'bootstrap';\n  const _renderLabel = '_render';\n\n  startMeasuring(renderAppLabel);\n  const platformRef = createServerPlatform(options);\n  try {\n    startMeasuring(bootstrapLabel);\n    const applicationRef = await bootstrap({platformRef});\n    stopMeasuring(bootstrapLabel);\n\n    startMeasuring(_renderLabel);\n\n    const measuringLabel = 'whenStable';\n    startMeasuring(measuringLabel);\n    // Block until application is stable.\n    await applicationRef.whenStable();\n    stopMeasuring(measuringLabel);\n\n    const rendered = await renderInternal(platformRef, applicationRef);\n    stopMeasuring(_renderLabel);\n    return rendered;\n  } finally {\n    await asyncDestroyPlatform(platformRef);\n    stopMeasuring(renderAppLabel);\n  }\n}\n"],"names":["measuringLabel","extraProviders","platform","findEventDispatchScript","doc","getElementById","EVENT_DISPATCH_SCRIPT_ID","removeEventDispatchScript","environmentInjector","applicationRef","injector","platformState","getDocument","appendSsrContentIntegrityMarker","annotateForHydration","eventTypesToReplay","regular","size","capture","get","CSP_NONCE","stopMeasuring","appendServerContextInfo","renderer","setAttribute","element","serverContext","insertEventRecordScript","appId","nonce","startMeasuring","JSON","stringify","Array","from","after","replayScript","callbacks","BEFORE_APP_SERIALIZED","console","warn","e","length","result","status","reason","asyncDestroyPlatform","platformRef","context","DEFAULT_SERVER_CONTEXT"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AA4EG,EAAA,MAAAA,cAAA,GAAA,sBAAA;;;;;;;;AAYDC,GAAAA,EAAAA,cAAA;gBAGE,CAAAD,cAA8D,CAAA;SAC9DE,QAAA;;gCAgBFC,CAAAC,GAAA,EAAA;SAAOA,GAAA,CAAAC,cAAA,CAAAC,wBAAA,CAAA;;AAQT,SAAAC,yBAAAA,CAAAH,GAAA,EAAA;;;;QAQQJ,cAAA,GAA4B,qBAAA;gCACf,CAAA;AACjB,EAAA,MAAAQ,mBAAA,GAAAC,cAAA,CAAAC,QAAA;AAEJ,EAAA,MAAAN,GAAA,GAAAO,aAAA,CAAAC,WAAA,EAAA;;AAKGL,IAAAA,yBAAA,CAAAH,GAAA,CAAA;AACM,IAAA;AACP;AACAS,EAAAA,+BAAyC,CAAAT,GAAA,CAAA;0BAEtB,GAAAU,qBAAA,CAAAL,cAAoC,EAAAL,GAAA,CAAA;MACrDW,kBAAA,CAAAC,OAAA,CAAAC,IAAA,IAAAF,kBAAA,CAAAG,OAAA,CAAmDD,IAAA,EAAA;gEACtC,EAAAF,kBAAA,EAAAP,mBAAA,CAAAW,GAAA,CAAAC,SAAA,EAAA,IAAA,CAAA,CAAA;AAGf,GAAA,MAAA;AAWAb,IAAAA,yBAAwB,CAAAH,GAAA,CAAA;AACxB;AAEA,EAAAiB,cAAA,CAAArB,cACI,CAAA;;AAcF,SAAAa,gCAAAT,GAAA,EAAA;;;;SAaDkB,uBAAAA,CAAAb,cAAA,EAAA;QACGC,QAAM,GAAAD;;;;;;AAWNc,MAAAA,QAAA,CAAAC,YAAW,CAAAC,OAAA,EAAA,mBAAA,EAAAC,aAAA,CAAA;;AAEb,GAAA,CAAA;;AAEIC,SAAAA,uBAAAA,CAAAC,KAAoB,EAAAxB,GAAA,EAAAW,kBAAa,EAAAc,KAAA,EAAA;sBAC7B,GAAgB,yBAAA;AAClB,EAAAC,eAAA,CAAA9B,cAAA,CAAA;;;;MACFe,kBAAA;;;8BAWA,GAAA,CAAA,4BAAA,CAAA,mBACF,GACF,CAAA,CAAA,EAAAa,KAAA,CAAA,EAAA,CAAA,GACF,CAAAG,EAAAA,IAAA,CAAAC,SAAA,CAAAC,KAAA,CAAAC,IAAA,CAAAlB,OAAA,CAGF,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,EAAAe,IAAA,CAAAC,SAAA,CAAAC,KAAA,CAAAC,IAAA,CAAAhB,OAAA,CAEA,CAAA,CAAA,CAAA,GAAA,CAAA,EAAA,CAAA;;uBAKoB,CAAAiB,KAAA,CAAAC,YAAA,CAAA;;+BAEF,CAAA;;;;;;;AAuBT,EAAA,MAAAC,SAAA,GAAA7B,mBAAA,CAAAW,GAAA,CAAAmB,qBAAA,EAAA,IAAA,CAAA;MACDD,SAAA,EAAA;;;;;;;;;AAgBIE,QAAAA,OAAA,CAAAC,IAAA,CACV,4CAAA,EAAAC,CAAA,CAAA;;;AAKI,IAAA,IAAA,cAAA,CAAAC,MAAA,EAAA;;QACF,IAAMC,MAAA,CAAAC,MAAA,KAAA,UAAA,EAAA;AACNL,UAAAA,OAAA,CAAAC,IAAA,CAAA,4CAAuB,EAAAG,MAAA,CAAAE,MAAA,CAAA;AAEvB;;;;qCAM2B,EAAA;;AAM/BC,SAAAA,oBAAAA,CAAAC,WAAA,EAAA;;;;;;;;;;;;AA8BA,EAAA,OAAAC,OAAA,CAAAN,MAAA,GAAAM,CAAAA,GAAAA,OAAA,GAAAC,sBAAA;;;;;;;;;;;;;;;;AA2BI,IAAA,MAAAjD,cAAA,GAAA,YAAA;mBACc,CAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}